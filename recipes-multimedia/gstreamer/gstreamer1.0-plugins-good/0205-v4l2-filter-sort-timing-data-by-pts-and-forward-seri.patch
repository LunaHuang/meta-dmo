From: Michael Olbrich <m.olbrich@pengutronix.de>
Date: Thu, 1 Nov 2012 17:51:23 +0100
Subject: [PATCH] v4l2: filter: sort timing data by pts and forward serialized
 events a the correct time

Signed-off-by: Michael Olbrich <m.olbrich@pengutronix.de>
---
 sys/v4l2/gstv4l2filter.c | 104 +++++++++++++++++++++++++++++++++++++++--------
 sys/v4l2/gstv4l2filter.h |   3 +-
 2 files changed, 89 insertions(+), 18 deletions(-)

diff --git a/sys/v4l2/gstv4l2filter.c b/sys/v4l2/gstv4l2filter.c
index b074ba2..05cca49 100644
--- a/sys/v4l2/gstv4l2filter.c
+++ b/sys/v4l2/gstv4l2filter.c
@@ -42,13 +42,30 @@ GST_DEBUG_CATEGORY (v4l2filter_debug);
 
 typedef struct _GstV4l2FilterTime
 {
+  GstClockTime order;
   GstClockTime pts;
   GstClockTime dts;
   GstClockTime duration;
   guint64 offset;
   guint64 offset_end;
+  GstEvent *event;
 } GstV4l2FilterTime;
 
+static gint
+v4l2filter_time_sort (gconstpointer a, gconstpointer b, gpointer userdata)
+{
+  GstV4l2FilterTime *atime = (GstV4l2FilterTime *) a;
+  GstV4l2FilterTime *btime = (GstV4l2FilterTime *) b;
+
+  /* we need to do this because pts is 64 bit */
+  if (atime->order < btime->order)
+    return -1;
+  else if (atime->order > btime->order)
+    return 1;
+  else
+    return 0;
+}
+
 #define gst_v4l2filter_parent_class parent_class
 G_DEFINE_TYPE (GstV4l2Filter, gst_v4l2filter, GST_TYPE_ELEMENT);
 
@@ -195,7 +212,8 @@ gst_v4l2filter_init (GstV4l2Filter * v4l2filter)
 
   g_mutex_init (&v4l2filter->preroll_lock);
 
-  v4l2filter->queue = g_async_queue_new_full (v4l2_filter_free_time);
+  g_mutex_init (&v4l2filter->queue_lock);
+  v4l2filter->queue = g_sequence_new (v4l2_filter_free_time);
 }
 
 static void
@@ -203,7 +221,8 @@ gst_v4l2filter_dispose (GObject * object)
 {
   GstV4l2Filter *v4l2filter = GST_V4L2FILTER (object);
 
-  g_async_queue_unref (v4l2filter->queue);
+  g_sequence_free (v4l2filter->queue);
+  g_mutex_clear (&v4l2filter->queue_lock);
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
@@ -443,7 +462,8 @@ stop_failed:
 static gboolean
 gst_v4l2filter_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 {
-  gboolean ret;
+  GstV4l2Filter *v4l2filter = GST_V4L2FILTER (parent);
+  gboolean ret = TRUE;
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_CAPS:
@@ -456,7 +476,28 @@ gst_v4l2filter_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
       break;
     }
     default:
-      ret = gst_pad_event_default (pad, parent, event);
+      g_mutex_lock (&v4l2filter->queue_lock);
+      if (GST_EVENT_IS_SERIALIZED (event)
+          && g_sequence_get_length (v4l2filter->queue) > 0) {
+        GstV4l2FilterTime *time;
+        GST_LOG_OBJECT (v4l2filter, "queue %" GST_PTR_FORMAT, event);
+        time = g_slice_new0 (GstV4l2FilterTime);
+        time->pts = GST_EVENT_TIMESTAMP (event);
+        time->event = event;
+        if (GST_CLOCK_TIME_IS_VALID (time->pts)) {
+          time->order = time->pts;
+        } else {
+          GstClock *clock = gst_system_clock_obtain ();
+          time->order = gst_clock_get_time (clock);
+          gst_object_unref (clock);
+        }
+        g_sequence_insert_sorted (v4l2filter->queue, time,
+            v4l2filter_time_sort, 0);
+        g_mutex_unlock (&v4l2filter->queue_lock);
+      } else {
+        g_mutex_unlock (&v4l2filter->queue_lock);
+        ret = gst_pad_event_default (pad, parent, event);
+      }
       break;
   }
 
@@ -580,6 +621,8 @@ v4l2_filter_src_task (GstPad * pad)
   GstV4l2Filter *v4l2filter = GST_V4L2FILTER (GST_OBJECT_PARENT (pad));
   GstV4l2Object *obj = v4l2filter->src_v4l2object;
   GstV4l2FilterTime *time;
+  GSequenceIter *iter;
+  gboolean found = FALSE;
 
   ret = gst_buffer_pool_acquire_buffer (obj->pool, &buffer, NULL);
   if (G_UNLIKELY (ret != GST_FLOW_OK))
@@ -591,15 +634,31 @@ v4l2_filter_src_task (GstPad * pad)
   if (G_UNLIKELY (ret != GST_FLOW_OK))
     goto out;
 
-  time = (GstV4l2FilterTime *) g_async_queue_try_pop (v4l2filter->queue);
-  if (time) {
-    GST_BUFFER_PTS (buffer) = time->pts;
-    GST_BUFFER_DTS (buffer) = time->dts;
-    GST_BUFFER_DURATION (buffer) = time->duration;
-    GST_BUFFER_OFFSET (buffer) = time->offset;
-    GST_BUFFER_OFFSET_END (buffer) = time->offset_end;
-    v4l2_filter_free_time (time);
+  g_mutex_lock (&v4l2filter->queue_lock);
+  while (1) {
+    iter = g_sequence_get_iter_at_pos (v4l2filter->queue, 0);
+    if (g_sequence_iter_is_end (iter))
+      break;
+    time = (GstV4l2FilterTime *) g_sequence_get (iter);
+    if (!time->event && found)
+      break;
+
+    if (time->event) {
+      GST_LOG_OBJECT (v4l2filter, "sending %" GST_PTR_FORMAT, time->event);
+      g_mutex_unlock (&v4l2filter->queue_lock);
+      gst_pad_push_event (v4l2filter->srcpad, time->event);
+      g_mutex_lock (&v4l2filter->queue_lock);
+    } else {
+      GST_BUFFER_PTS (buffer) = time->pts;
+      GST_BUFFER_DTS (buffer) = time->dts;
+      GST_BUFFER_DURATION (buffer) = time->duration;
+      GST_BUFFER_OFFSET (buffer) = time->offset;
+      GST_BUFFER_OFFSET_END (buffer) = time->offset_end;
+      found = TRUE;
+    }
+    g_sequence_remove (iter);
   }
+  g_mutex_unlock (&v4l2filter->queue_lock);
 
   gst_pad_push (pad, buffer);
   return;
@@ -626,9 +685,10 @@ gst_v4l2filter_activate_mode (GstPad * pad, GstObject * parent, GstPadMode mode,
       if (active)
         result = gst_v4l2filter_start_task (v4l2filter);
       else {
-        gpointer mem;
-        while ((mem = g_async_queue_try_pop (v4l2filter->queue)))
-          v4l2_filter_free_time (mem);
+        g_mutex_lock (&v4l2filter->queue_lock);
+        g_sequence_remove_range (g_sequence_get_begin_iter (v4l2filter->queue),
+            g_sequence_get_end_iter (v4l2filter->queue));
+        g_mutex_unlock (&v4l2filter->queue_lock);
         /* FIXME: is this correct? */
         gst_v4l2_object_unlock (v4l2filter->src_v4l2object);
         if (v4l2filter->src_v4l2object->pool) {
@@ -676,13 +736,23 @@ gst_v4l2filter_sink_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
     return GST_FLOW_FLUSHING;
   }
 
-  time = g_slice_new (GstV4l2FilterTime);
+  time = g_slice_new0 (GstV4l2FilterTime);
   time->pts = GST_BUFFER_PTS (buffer);
   time->dts = GST_BUFFER_DTS (buffer);
   time->duration = GST_BUFFER_DURATION (buffer);
   time->offset = GST_BUFFER_OFFSET (buffer);
   time->offset_end = GST_BUFFER_OFFSET_END (buffer);
-  g_async_queue_push (v4l2filter->queue, time);
+  if (GST_CLOCK_TIME_IS_VALID (time->pts)) {
+    time->order = time->pts;
+  } else {
+    GstClock *clock = gst_system_clock_obtain ();
+    time->order = gst_clock_get_time (clock);
+    gst_object_unref (clock);
+  }
+
+  g_mutex_lock (&v4l2filter->queue_lock);
+  g_sequence_insert_sorted (v4l2filter->queue, time, v4l2filter_time_sort, 0);
+  g_mutex_unlock (&v4l2filter->queue_lock);
 
   ret =
       gst_v4l2_buffer_pool_process (GST_V4L2_BUFFER_POOL_CAST (obj->pool),
diff --git a/sys/v4l2/gstv4l2filter.h b/sys/v4l2/gstv4l2filter.h
index d42cf56..4b8545f 100644
--- a/sys/v4l2/gstv4l2filter.h
+++ b/sys/v4l2/gstv4l2filter.h
@@ -67,7 +67,8 @@ struct _GstV4l2Filter {
   GstV4l2Object * src_v4l2object;
   GstV4l2Object * sink_v4l2object;
 
-  GAsyncQueue *queue;
+  GSequence *queue;
+  GMutex queue_lock;
   gboolean incomplete_caps;
 };
 
